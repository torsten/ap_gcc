\section{Guideline - Code that builds on GCC and Visual C++}
This section contains a list of the most common problems we found in the code of CGA and their solution.

\subsection{Paths} To be valid on Windows and Unix platforms, a path \textbf{must not} contain backslashes as separators. The only valid path separator for both platforms is the slash symbol \textbf{/}. So a valid path looks like this: 
\begin{verbatim}
	"this/is/a/valid/path" 
\end{verbatim}

\subsection{Const correctness} 

\subsection{Templates} The GCC's parser for template type name behaves slightly different than the Visual C++ ones. For example this is a valid definition in Visual C++: 
\begin{verbatim}
	std::list<std::pair<int, int>> myListOfIntPairs; 
\end{verbatim}

This is \textbf{not} valid while compiling with GCC. You have to separate \textbf{>} symbols using a space, else, GCC will throw a parser error. So this is the valid equivalent, which compiles on GCC and Visual C++: 
\begin{verbatim}
	std::list<std::pair<int, int> > myListOfIntPairs; 
\end{verbatim}

\subsection{Member function declarations} When declaring a member function inside the class statement, some people tent to prepend the name of the class to the method name. This may increase readability when inheriting several levels:
\begin{verbatim}
    class A {
    public:
        virtual void A::funcFromA();
    };
    
    class B : public A {
    public:
        virtual void A::funcFromA();
        virtual void B::funcFromB();
    };
    
    class C : public B {
    public:
        virtual void A::funcFromA();
        virtual void B::funcFromB();
        virtual void C::funcFromC();
    };
\end{verbatim}

The problem is, this \textbf{is not} a valid syntax for GCC. You \textbf{must not} prepend the class name to the member function. So the above declaration is valid for GCC like this:
\begin{verbatim}
    class A {
    public:
        virtual void funcFromA();
    };
    
    class B : public A {
    public:
        virtual void funcFromA();
        virtual void funcFromB();
    };
    
    class C : public B {
    public:
        virtual void funcFromA();
        virtual void funcFromB();
        virtual void funcFromC();
    };
\end{verbatim}

\subsection{windows.h} You \textbf{must not} include windows.h because all the types and functions provided by windows.h are highly Windows specific and will not compile nor run on other platforms. In general you will find the same functionality in QtCore. When using QtCore's functionality, it is easy to compile and run the code on all the platforms supported by Qt.

\subsection{for each() vs. foreach() vs. for()} Visual C++ provides a construct which looks like this:
\begin{verbatim}
    for each(int i in myIntList) {
        // loop code here
    }
\end{verbatim}
This \textbf{is not} available on GCC. There this cannot compile on both compilers. But the for each way is handy, so a cross compiler alternative is again the usage of Qt. Qt provides a construct like this:
\begin{verbatim}
    foreach(int i, myIntList) {
        // loop code here
    }
\end{verbatim}
Using this construct the resulting code is again cross compiler compatible and stays readable and handy.

\subsection{stdext vs. \_\_gnu\_cxx vs. tr1} Datatypes like the hash\_map are currently not part of the C++ Standard Template Library. But compiler vendors provide extensions in their own namespaces. Visual C++ provides this in the stdext namespace, GCC up to version 4.2 in the \_\_gnu\_cxx namespace. Since version 4.3 of GCC, the hash\_map was moved to the namespace std::tr1 and renamed to unordered\_map. The new C++ standard C++0x is on it's way and will contain the unordered\_map. So it is very likely that a new namespace will contain unordered\_map. For now, we found the following solution to the problem:
\begin{verbatim}
    #if __GNUC__ == 4 && __GNUC_MINOR__ >= 2
    #  if __GNUC_MINOR__ == 2
    #    include <ext/hash_map>
    #    include <ext/hash_set>
    #    define HASHMAP_TYPE      __gnu_cxx::hash_map
    #    define HASHMULTIMAP_TYPE __gnu_cxx::hash_multimap
    #    define HASHSET_TYPE      __gnu_cxx::hash_set
    #    define HASHMAP_NAMESPACE_OPEN  namespace __gnu_cxx {
    #    define HASHMAP_NAMESPACE_CLOSE }
    #  else // __GNUC_MINOR__ > 2
    #    include <tr1/unordered_map>
    #    include <tr1/unordered_set>
    #    define HASHMAP_TYPE      std::tr1::unordered_map
    #    define HASHMULTIMAP_TYPE std::tr1::unordered_multimap
    #    define HASHSET_TYPE      std::tr1::unordered_set
    #    define HASHMAP_NAMESPACE_OPEN  namespace std { namespace tr1 {
    #    define HASHMAP_NAMESPACE_CLOSE }}
    #  endif
    #else // __GNUC__ != 4 && __GNUC_MINOR__ < 2
    #  error "unsupported gcc version, need gcc 4.2 or higher"
    #endif
\end{verbatim}
Yes, this is just the GCC part, to include Visual C++ too, it needs still a bit more code, which is as well included in our branch of CGA. So to keep the cross compiler compatibility the marcos from above should be used. 

\subsection{Qt is the key} Qt provides a great way to write platform independent code. QtCore contains lots of things which replace pthreads\_create() or WaitForSingleObject() which else would break cross platform compatibility. 

