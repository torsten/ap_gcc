\section{Tutorial} This section shows how to profile a project step by step. In general, the process is quite similar to the process needed to profile a project with the Windows version of callmon. Big differences only appear in the build configuration due to differences in the compiler switches needed by GCC.

\subsection{Preparing the build process} How to prepare the build process.

\subsubsection{Parameters to GCC} This is a list of parameters needed by GCC when profiling with unix fact extraction.

\paragraph{Compile with -g} Enable debug information.

With this option enabled GCC builds debug information into the resulting binary. This is needed my metacreator to resolve source file name, line numbers and other valuable debugging information.

\paragraph{Compile with -finstrument-functions} Enable instrumentation.

This GCC parameter is the key. With this option enabled, GCC inserts calls to instrumentation functions right after a function was called and right before a functions return. If you do not provide this option in the compilation process, no calls will be made to the unix callmon lib, and therefor no profiling information can be retrieved.

\paragraph{Compile with -fno-inline} Disable inlining of functions.

This disables the inlining of functions which is done by the compiler automatically to optimize execution speed by eliminating function call overhead. Since we are profiling on a function execution level, we cannot profile inlined function, so all the functions inlined by the compiler cannot appear in the call graph. To be sure this cannot happen, use -fno-inline as a GCC option. You might skip this if you want. You still might get good profiling results for the calls you are interested in, but you have been warned! Take care!

\paragraph{Link unixcallmonlib as the last library} Ensure the right profiling functions are used.

It might happen, that other libraries as well provide the profiling functions that unix callmon lib provides. If this happens, it is important to ensure that the versions of the unix callmon lib are the ones linked in. This is done by adding the -lunixcallmon\_lib parameter as the last one.

\paragraph{On Linux, link with -Wl,-Bsymbolic} Make function calls patchable.

Without this option, symbolic function call information are removed from the resulting binary on Linux. This prevents patch and patch\_clean from finding the call locations and makes it impossible to remove those calls from the binary. 

\subsubsection{Resulting build configuration} √çf the project you want to analyze is build using make, you might add the following to the projects Makefile:
\begin{verbatim}
  CFLAG   += -g -finstrument-functions -fno-inline 
  LDFLAGS += -Wl,-Bsymbolic -L/path/to/callmonlib -lunixcallmon_lib
\end{verbatim}

\subsection{Building the application} With all the above mentioned this set up, you build your project by just typing \emph{make}.

\subsection{Patching the executable} As soon if the build process is finished, you end up with an executable or library which has all the profiling mechanism build in. At this point, every single function which was just compiled by GCC is now enriched by profiling logic. Since this may be a lot, you might want to exclude several functions or groups of functions from the profiling process. This is done by patching the binary. Technically, the calls to the instrumentation functions get overwritten by NOP operations, so almost no overhead is involved in calling functions removed from the profiling process.

\subsubsection{Patch clean} The first thing to do is call patch\_clean on the binary like this:
\begin{verbatim}
  $ patch_clean myBinary myBinary.patch
\end{verbatim}
The first parameter specifies the binary to patch. The second parameter specifies a patch file name. In this patch file, patch\_clean will write out all the locations from which profiling calls were removed along with the opcodes removed that realized the call. This information in needed my patch to re-include the call opcodes for certain functions in the next step.

\subsubsection{Patch} At this point, profiling logic is re-added to the functions of interest. This is done by specifying two groups of function name patterns in a pattern file. This is exactly the as with Windows callmon.

Provide a list of patterns in the include section, as well a list of patterns in the exclude section. Then, call patch like this:
\begin{verbatim}
  $ patch myBinary myBinary.patch myPatternsFile.txt
\end{verbatim}
You may leave the patterns file parameter empty to re-include all functions in the profiling process. Like this:
\begin{verbatim}
  $ patch myBinary myBinary.patch
\end{verbatim}

\subsection{Using CGA Toolbar} The CGA Toolbar can be used as usual. It needs to environment variable CALLMON\_HOME setup. This variable has to contain the path, where the log files are created. So lets say, you have a directory structure like this:

\begin{verbatim}
  <working dir>
  |
  |- myBinary
  |- myBinary.patch
  |- myPatternsFile.txt
\end{verbatim}

Create a directory where the CGA Toolbar can operate on like this:
\begin{verbatim}
  $ mkdir -p logs/myBinary
\end{verbatim}

You end up with a directory structure like this:
\begin{verbatim}
  <working directory>
  |
  |- logs
  |  |
  |  |- myBinary
  |     |
  |     |
  |
  |- myBinary
  |- myBinary.patch
  |- myPatternsFile.txt
\end{verbatim}

Now, fire up the CGA Toolbar like this:
\begin{verbatim}
  $ CALLMON_HOME="<working directory>" cgatoolbar
\end{verbatim}

myBinary should now show up in the drop down menu in the CGA Toolbar. If you now hit the start button, CGA Toolbar will create a file called callmon.cmd:
\begin{verbatim}
  <working directory>
  |
  |- logs
  |  |
  |  |- myBinary
  |     |
  |     |- callmon.cmd
  |
  |- myBinary
  |- myBinary.patch
  |- myPatternsFile.txt
\end{verbatim}

This tells callmon to log function calls. Hitting the stop button, will remove this file. You are now ready to run you application an record profiling information.

\subsection{Running the application}

\subsection{Using Metacreator}

\subsection{Loading the trace(s) into CGA} 
