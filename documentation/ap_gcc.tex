\documentclass[]{article}

\usepackage{pdfsync}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc} 
\usepackage[english]{babel} 
% \usepackage[T1]{fontenc} 

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}
% Multipart figures
%\usepackage{subfigure}
% More symbols
%\usepackage{amsmath}
%\usepackage{amssymb}
%\usepackage{latexsym}
% Surround parts of graphics with box
\usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% url package
\usepackage{url}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi
\ifpdf 
\usepackage[pdftex]{graphicx} \else 
\usepackage{graphicx} \fi

% command to highlight todos
\usepackage{color}
\definecolor{Orange}{rgb}{1,0.5,0}
\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{Orange}{[[#1]]}}}}

% sets the indent of the paragraph
\setlength{\parindent}{0cm}

% our commands to mark-up stuff
\newcommand{\inlinecode}[1]{\emph{#1}}
\newcommand{\toolname}[1]{\texttt{#1}}
\newcommand{\pathname}[1]{\texttt{#1}}



\title{AP GCC - CGA tool chain on unix systems} 
\author{ Torsten Becker, Frederik Rudeck, Robert Timm }

\date{2009-08-01}

\begin{document}

% sets the langauge for the listings package	
\lstset{language=C++}

\ifpdf \DeclareGraphicsExtensions{.pdf, .jpg, .tif, .png} \else \DeclareGraphicsExtensions{.eps, .jpg} \fi

\maketitle
\begin{abstract}
	The CGA - Call Graph Analyzer - system developed at the HPI was indented for Windows based systems only. We ported this tool chain to Mac OS X and Linux systems.

CGA is useful for:

\begin{itemize}
	\item Program understanding
	\item Debugging
	\item Performance analysis
	\item Quality Assurance
\end{itemize}

\todo{TODO add why CGA is useful in general}

Viewing an application's call trace in graphical form can be an educational experience. Doing so can help you understand an application's internal behavior and obtain information for program optimization. For example, by optimizing those functions that are called most often, you can get the greatest performance benefit from the least amount of effort. Additionally, a call trace can identify the maximum call depth of user functions, which you can then use to efficiently bind the memory that the call stack uses (an important consideration in embedded systems).

At some stage in everyone's programming career, they will need to read through a lot of code written by another programmer. An important part of program comprehension is building a picture of how the program is structured from a high-level view and call graphs can be an invaluable aid when building this picture. This is particularly useful if the original programmer uses clear function names.

\url{http://www.hpi.uni-potsdam.de/doellner/research/softvis.html}

\todo{why port to linux and mac}
	
\todo{blow this a lil' up}
\end{abstract}

\newpage

\tableofcontents
\newpage


% \addtolength{\parskip}{\baselineskip}
\setlength{\parskip}{0.27cm}


\input{chapters/results} 

\newpage

\input{chapters/challenges} 

\newpage

\input{chapters/requirements} 

\newpage

\input{chapters/cmake} 

\newpage

\input{chapters/unixfe} 

\newpage

\input{chapters/tutorial} 

\newpage

\input{chapters/guidelines} 

\newpage

\input{chapters/finalwords} 

\bibliographystyle{plain} 
\bibliography{}

\end{document} 
